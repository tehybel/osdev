
--- part A ---

Time: 10:30-13:30, 14-15:15, 9:30-10:45

TODO write the writeup



--- part B ---

Time: 10:45-13:00, 9:45-14:45, 10:30-13, 8:30-11

- spent a long time being stuck because of bugs; see description below. The
  issue was that the second level of page tables were shared between all
  processes and the kernel.

TODO write the writeup


--- part C ---

Time: 11-12:15, 10:30-12:30, 13-TODO

- again stuck due to bugs (right now I'm getting clock interrupts in kernel
  land, although I've disabled interrupts there??)

TODO write the writeup





-----------------------------

Debugging the page tables issue:

Something here doesn't make sense. We see that process 1002 allocates its
exception stack:

	page_insert 0xeebff000 -> 0x0039f000 (pgdir: 0xf03a3000)
	[00001002] allocated 0xeebff000 -> 0x0039f000

This happens in sys_page_alloc, which makes sense. At that point, process 1000
is acting on behalf of process 1002.

Here, page_alloc allocates 39f000. But then soon afterwards that page gets
freed:

	freed 0x39f000

And this should not happen!

When does it get freed? I broke in gdb and backtraced:

	Breakpoint 1, page_free (pageinfo=0xf0287cf8) at kern/pmap.c:446
	446		cprintf("freed 0x%x\n", pa);
	1: pa = 0x39f000
	(gdb) bt
	#0  page_free (pageinfo=0xf0287cf8) at kern/pmap.c:446
	#1  0xf0101951 in page_decref (pinfo=0xf0287cf8) at kern/pmap.c:463
	#2  0xf0101d24 in page_remove (pgdir=0xf0285000, va=0xeebff000) at
	kern/pmap.c:654
	#3  0xf0101c14 in page_insert (pgdir=0xf0285000, pp=0xf0287d28, 
	va=0xeebff000, perm=0x2) at kern/pmap.c:592
	#4  0xf0105f67 in page_fault_handler (tf=0xf02c607c) at kern/trap.c:400

It's getting freed during a page_insert inside the page fault handler. In
which process? 

	(gdb) p (cpus[cpunum()].cpu_env)->env_id
	$6 = 0x1001

This matches with process 1001 doing an insert into the kernel page table.
That is, the following lines result in the memory at 39f000 getting freed:

    cprintf("[%08x] insert 0x%08x\n", curenv->env_id, page2pa(pinfo));
	if (page_insert(kern_pgdir, pinfo, (void *) UXSTACKBASE, PTE_W))
		goto destroy_env;


So we're inserting an entry into the kernel page directory. This removes the
old entry. And that's how 39f000 gets freed. But *HOW* did 39f000 ever end up
in the kernel page directory!?

It could have happened during page fault handling. But if that's the case, we
should see a line with "[%08x] insert 0x%08x\n" in the output. But we don't!

	dynabox@dynabox:~/lab$ make qemu | grep '\] insert 0x'
	[00001000] insert 0x003ad000
	[00001000] insert 0x003ad000
	[00001000] insert 0x003ad000
	[00001001] insert 0x003a5000
	[00001001] insert 0x003a5000

So now the big question is: HOW does 39f000 end up in the kernel page table??

Well, it could get inserted directly with page_insert. But we only see one
call to page_insert with 39f000. And that's when process 1002 inserts the page
into its own page table.

Are there other functions which insert into the page table? Well, you'd have
to call pgdir_walk. The only other caller of that is page_lookup. So who calls
page_lookup? I checked with cscope and no caller modifies the looked-up PTE.

Then another option is that the kern_pgdir and that of process 1002 somehow
share some physical pages. But that should never happen. Can we confirm this?

We could print the page tables. When should we do this? When 1002 allocates
its exception stack. Okay.



OH. I just realized that in env_setup_vm we *ARE* setting up a new
environment's page directory to look exactly like that of the kernel. But we
are copying each PDE. This means that the second level of page tables will be
shared! And this is NOT okay. When we modify the kernel's page table we'll
also affect that of every process, and that's really not what we want.




-------------------


Debugging the clock interrupts issue:

The problem is that when I run "make CPUS=2 run-hello" then an assertion
fails. But if I set CPUS=1 there is no problem.

The assertion failure is:

	kernel panic on CPU 1 at kern/trap.c:297: assertion failed: (tf->tf_cs & 3) == 3

It happens on the secondary CPU. It happens no matter which program I try to
run.

The faulting line looks like this:

    if (tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER) {
        assert ((tf->tf_cs & 3) == 3);
    }

It's inside the trap() function which handles all exceptions.

When did this start happening? Since I enabled exceptions. I did so by setting
the IF flag on the eflags register in user-land only. That's in env_alloc:

    e->env_tf.tf_eflags |= FL_IF;

If I comment out that line... it still fails. I thought that was not the case.

How can I revert to a non-failing state, then? Maybe it has to do with my new
setting up of the IDT?

Yes, commenting out this line removes the fault:

	SETGATE (idt[IRQ_OFFSET + IRQ_TIMER], 0, GD_KT, trap_irq_timer, 3)

But if I attach gdb I see that CPU1 is just hitting badint instead, meaning
that the clock interrupt isn't handled properly.

So.. we can now conclude that the problem is *not* about whether clock
interrupts happen in user mode. The problem was not caused by me setting the
interrupt flag in eflags in userland. So let's forget that part again.

The problem is that timer interrupts now happen in kernel mode, but only on
CPU 1.

I expect this to not happen, because I've explicitly disabled interrupts on
secondary processors.

Secondary processors start in mpentry_start. The first instruction there is
"cli" which clears the interrupt flag.

I'm reading up to confirm this. Wikipedia
(https://en.wikipedia.org/wiki/Interrupt_flag) says:

	If the flag is set to 1, maskable hardware interrupts will be handled. If
	cleared (set to 0), such interrupts will be ignored. IF does not affect
	the handling of non-maskable interrupts or software interrupts generated
	by the INT instruction.

So it seems that there are interrupts which can't be masked (NMIs). Is the
timer interrupt one? ... I can't actually find the information about this
online. 

But here's a quote from the exercise material:

	External interrupts are referred to as IRQs ... For example, the clock
	interrupt is IRQ 0 ... we make a key simplification ... External device
	interrupts are always disabled when in the kernel ... External interrupts
	are controlled by the FL_IF flag bit of the %eflags register

So that's confirmed.

Also the first thing we do in trap() is to assert that the FL_IF bit isn't set
in eflags. So external interrupts really are disabled in the kernel. But we
get them anyway?

Do secondary processors even get past that first "cli" instruction? Yes,
because we see that a cprintf() in mp_main is getting hit.

What if we mark the timer interrupt as a trap? It would make some sense,
because the instruction where the interrupt happened should indeed be
restarted. Then we get another assertion failure:

	kernel panic on CPU 1 at kern/trap.c:293: assertion failed:
	!(read_eflags() & FL_IF)

This confuses me. Why does marking an interrupt as a trap cause the eflags
register to change in kernel mode?

Can qemu or gdb help debug interrupts?


Hmm.. Maybe my assertions are just wrong. Maybe clock interrupts can sometimes
happen in kernel land, without this being a problem.

Yeah, I tried changing the code to allow kernel-land timer interrupts. Then we
just call sched_yield. I guess that's a way to let the CPU be idle, then. Then
it can wake up periodically and look for new scheduled tasks.

Then in the end the exercise description was just really misleading.



