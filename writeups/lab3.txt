
Time: 21-00:30


In the first part of this lab we implement functions for manipulating
"environments"; an environment is more-or-less a synonym for "process", but we
call them environments because there are differences:

	 We introduce the term "environment" instead of the traditional term
	 "process" in order to stress the point that JOS environments and UNIX
	 processes provide different interfaces, and do not provide the same
	 semantics. 

An environment holds things like the register state for a thread, a pointer to
its page directory, etc.

We also implemented a function, load_icode(), which will load an ELF file into
a user land address space.

Thus we can now create a new environment, load code into it, and even do a
context switch to run code in userland!

Unfortunately interrupts are not yet handled properly, so the processor is
stuck in userland; it will crash on the first int 0xXX instruction. Handling
interrupts is the last part of this lab.

---------

Time: 12:30-TODO

In the second part of the lab our task is to extend the operating system to
properly handle exceptions.

To program this we first need to understand some theory. We read about
interrupts and exceptions in chapter 9 of the 80386 programmer's manual:

	https://pdos.csail.mit.edu/6.828/2016/readings/i386/c09.htm

Other useful links:

	http://stackoverflow.com/questions/3149175/what-is-the-difference-between-trap-and-interrupt
	http://wiki.osdev.org/Exceptions
	https://en.wikipedia.org/wiki/Task_state_segment

There are two concepts: interrupts and exceptions. An exception is a type of
interrupt. The processor can raise an exception due to executing an
instruction. For example "int3" will trigger a breakpoint exception. But
interrupts can also happen for asynchronous reasons that have nothing to do
with the currently executing code, e.g. when receiving a network packet.

Exceptions are further split into three categories:
- A trap is an exception which increments the $pc, e.g. int3 for breakpoints
- A fault is an exception which does not increment the $pc; instead we can
  attempt recovery and the processor retries execution of the instruction
- An abort is a critical exception, e.g. on hardware failure. This should not
  be relevant to us.

When an interrupt happens, the processor performs a "light context switch",
transferring execution to an interrupt handler, a special chunk of code. This
code is typically run in kernel mode, not user mode.

How does the processor know where to jump to when an interrupt occurs? Each
interrupt has a number, for example a breakpoint interrupt has number 3. The
processor uses this number to index into a table of 8-byte entries. This is
the Interrupt Descriptor Table (IDT). The table base address is loaded and set
via the LIDT and SIDT instructions and resides in the IDT register (IDTR).

Each 8-byte entry in the IDT is called an Interrupt Descriptor. The layout of
a descriptor is here:

	https://pdos.csail.mit.edu/6.828/2016/readings/i386/s09_05.htm

A descriptor determines the $pc-value where the interrupt handler resides. It
also determines whether the handler should run in kernel- or user-mode.

The code of the interrupt handler needs a stack it can use while executing.
How does the processor know which value to put into the $sp register when it
switches to the interrupt handler? There is a structure called the Task State
Segment (TSS) which holds this information, along with many other things.

The processor has a Task Register (TR) which contains a segment selector, just
like the $cs and $ss registers do. This corresponds to an entry in the GDT.
The TR can be loaded with the LTR instruction. 

So to switch to an interrupt handler, the processor finds a selector in the
TR, looks it up in the GDT, finds a TSS struct in the corresponding segment,
and there it finds the needed $sp-value.



Returning from theory to practice, our task in this part of the lab is to
handle exceptions, e.g. page faults (exception #14), debug exceptions
(exception #3) and so on. Exceptions have numbers from 0 to 31. Other
interrupts have numbers from 32 to 255. In this part of the lab we focus on
exceptions.



