\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{fancyvrb}
\usepackage{color}
\usepackage{bm}
\usepackage{listings}
\usepackage{soul,xcolor}
\usepackage[htt]{hyphenat} % allows breaks inside texttt
\usepackage[acronym, toc]{glossaries}
\setstcolor{red}

\usepackage{xcolor}

% this makes links prettier
% TODO: find a nicer way to indicate that text is a link.
\hypersetup{
    colorlinks,
    linkcolor={blue!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!50!black}
}

\lstset{language=C}
\lstset{basicstyle=\ttfamily\footnotesize}

\newglossaryentry{elf}{
	name=ELF,
	description={Executable and Linkable Format; a file format used to store
	executable programs. An ELF file describes the address at which each
	section of program code or data should be loaded.}
}

\newglossaryentry{cr0}{
	name=\texttt{cr0},
	description={Control Register 0. It holds bits which determine how the
	processor operates. It e.g. determines whether paging and protected mode
	are enabled.}
}

\newglossaryentry{cr3}{
	name=\texttt{cr3},
	description={Control Register 3. It points to the current page table.}
}

\newglossaryentry{esp}{
	name=\texttt{esp},
	description={Extended Stack Pointer register.}
}

\newglossaryentry{eip}{
	name=\texttt{eip},
	description={Extended Instruction Pointer; a register which holds the
	address of the next instruction to be executed.}
}

\newglossaryentry{eflags}{
	name=\texttt{eflags},
	description={A register which holds various flags that mostly reflect the
	properties of the most recently executed instruction. For example the
	signed flag is set during a subtraction whose result is below zero.}
}

\newglossaryentry{cs}{
	name=\texttt{cs},
	description={Code Segment selector register; it holds an index into the
	\gls{gdt}. Its lower two bits determine the \gls{cpl}.}
}

\newglossaryentry{cpl}{
	name=CPL,
	description={Current Privilege Level; the current ring in which the
	processor is executing. CPL=3 means ring, 3, i.e., user-mode, while CPL=0
	means ring 0, i.e. kernel-mode.}
}

\newglossaryentry{gdt}{
	name=GDT,
	description={Global Descriptor Table; a table which holds descriptors,
	each of which describes a segment of memory and its permissions.}
}

\newglossaryentry{pte}{
	name=PTE,
	description={Page Table Entry; a 32-bit integer which stores a physical
	address to which a virtual address maps, as well as some status bits.}
}
\newglossaryentry{mmu}{
	name=MMU,
	description={Memory Management Unit.}
}
\newglossaryentry{tlb}{
	name=TLB,
	description={Translation Lookaside Buffer.}
}

\newglossaryentry{pde}{
	name=PDE,
	description={Page Directory Entry; a 32-bit integer which stores a
	physical address of a second-level node in the page table, as well as some
	status bits.}
}

\newglossaryentry{idt}{
	name=IDT,
	description={Interrupt Descriptor Table; a table which describes the
	address of the handler that should be run when a given interrupt or
	exception is triggered.}
}

\newglossaryentry{idtr}{
	name=IDTR,
	description={A register which holds the physical address of the \gls{idt}.}
}

\newglossaryentry{tr}{
	name=TR,
	description={Task Register; a register which is used as an index into the
	\gls{gdt} to find the \gls{tss}.}
}

\newglossaryentry{tss}{
	name=TSS,
	description={Task State Segment; a data structure which, among other
	things, determines the \gls{esp}-value used during a context switch
	triggered by an exception or interrupt.}
}


\makeglossaries



\title{
\line(1,0){250}\\
\Large \bfseries
TODO: write a \\
nice title here
\line(1,0){250}
}
\author{Thomas Hybel}
\date{Aarhus University \\ October 2017}

\begin{document}
\pagenumbering{roman}
\maketitle

\begin{abstract} 
\noindent 
TODO: write an abstract here.
\end{abstract}
\newpage

\tableofcontents
\newpage
\pagenumbering{arabic}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}


- introduction
	- what are we trying to do
	- how are we doing it
		- following the course from MIT
	- why are we doing it
	- overview of the coming chapters

% TODO: write about our development environment, i.e., that we're using QEMU.

% TODO: write that you can use "git checkout lab1" to go back to the end of
% lab1, etc.
% TODO: say it's an exokernel, talk about what that means for our later
% design
% TODO: refer to the abbreviations list.

%%%%% LAB 1 %%%%%

\section{Lab 1}

In this lab we wrote initialization code for our operating system. This code
sets up a rudimentary page table and switches the processor from 16-bit real
mode to 32-bit protected mode. We also wrote a boot loader, which is a small
program that loads the main kernel from disk and transfers control to it.

\subsection{The boot process}
To understand the purpose of a boot loader, it is first necessary to have an
overview of the process which an x86 machine goes through upon startup.

% source: https://en.wikipedia.org/wiki/BIOS
When an x86 machine starts, its BIOS code is run. The BIOS initializes some of
the system's hardware components (e.g., keyboard, graphics card, and hard
drive). The BIOS will then load one sector (512 bytes) from the boot medium
into memory at a hard-coded address (0x7C00). Once this first sector is loaded
into memory, the BIOS will transfer execution to the loaded code.

The first sector will typically contain a small program known as the boot
loader. Its purpose is to load the main kernel from disk and transfer
execution to it.

Before the boot loader loads the kernel, we first run some initialization code
which sets up a more comfortable environment for the boot loader and kernel to
work in.



\subsection{Initialization code}
When the BIOS jumps into our code, the processor is running in 16-bit real
mode. However the code produced by a modern compiler expects to run in 32-bit
protected mode. We therefore needed to write code which performs this
switching of processor modes.

The main difference between real mode and protected mode is how address
resolution is performed. In real mode, accessing a physical address is done
using a segment selector register and a general-purpose register. In
contast, protected mode allows (but does not require) the use of
\emph{paging}, i.e., the mapping from virtual from physical addresses using a
page table.

Since we want our operating system to use virtual memory, we certainly want to
switch to protected mode. We do not immediately enable paging, however.

To switch to protected mode, a bit needs to be set in the control register
\gls{cr0}. We do so with the following assembly code:
\begin{verbatim}
# protected mode enable flag
.set CR0_PE_ON, 0x1 
movl    %cr0, %eax
orl     $CR0_PE_ON, %eax
movl    %eax, %cr0
\end{verbatim}

To switch to 32-bit mode, we must update the \gls{cs} (code
segment) register. This register is an offset into a table called the Global
Descriptor Table (\gls{gdt}) which contains a number of descriptors. Each
descriptor has a bit which determines whether the chosen segment is a 32-bit
or a 16-bit segment. We use the \texttt{ljmp} instruction to update the
\gls{cs} register.
% TODO: possibly elaborate more on the GDT.

Once our code has switched to 32-bit protected mode, it executes the boot
loader. At this point the processor is in a state where it can execute
compiled C code, which means that we no longer need to hand-write assembly.

The file \texttt{boot/boot.S} contains the code that performs the described
tasks.



\subsection{The boot loader}
It is the task of the boot loader to load the main kernel and transfer
execution to it. The boot loader must do this using no more than 512 bytes of
code, minus the bytes used by the initialization code.

Our kernel will be compiled into an \gls{elf} file. The boot loader will parse
this \gls{elf} file, using the information therein to load the code and data
of the kernel to the right physical addresses.

% TODO: possibly include information about the ELF file format here.

Once the boot loader has finished loading the kernel, it determines the entry
point address from the \gls{elf} file and jumps there, transferring execution to the
kernel.

\subsection{Minimal kernel code}
At this point our kernel can finally run. However it does not yet have much
functionality. Unlike user-mode programs, the kernel does not have access to a
C standard library, unless we write one ourselves.


% TODO: document that we were given the serial connection code via the MIT
% course
As a start, we would like to have the ability to input and output text.
Our kernel can use the \texttt{inb} and \texttt{outb} instructions to
communicate with the outside world via a serial connection. We used this to
write out a message and confirm that the kernel runs.

Using instructions such as \texttt{inb} and \texttt{outb} to communicate with
an input/output device is known as Programmed Input/Output (PIO). It is a
technique we will be using throughout our operating system development.


% TODO: should note that our boot loader isn't actually used in the end.




%%%%% LAB 2 %%%%%

\section{Lab 2}

The goal of this lab was to write code which sets up the page table, so that
our operating system can use virtual memory. Before we could set up the page
table, we first needed to implement a subsystem which manages the physical
memory of the system.

\subsection{Physical page allocation}
A given system has a limited amount of physical memory, depending on how much
RAM the machine has. This memory is split up into a number of pages. On x86, a
page is 4096 bytes of memory. In hex, 4096 is 0x1000, which means that pages
are always aligned on 0x1000-byte boundaries.

% sources: https://en.wikipedia.org/wiki/Nonvolatile_BIOS_memory
% http://wiki.osdev.org/CMOS
To find out how much memory is available on the system, we query a memory area
called the CMOS. The CMOS is an area of memory which holds the amount of
system RAM. We can read from the CMOS using PIO to figure out how many pages
of physical memory are available to the kernel.

For each page, the kernel must keep track of whether it is in use or not, and
if so, how many references there are to the given page. To accomplish this,
metadata about each page is stored in a \texttt{PageInfo} struct. For example,
the \texttt{PageInfo} struct holds the reference count of each page. The
kernel has an array of \texttt{PageInfo} structs, called \texttt{pages}.
Each entry of the \texttt{pages} array directly corresponds to one physical
page of memory, such that the first entry in \texttt{pages} holds metadata
about the first page of physical memory, and so on.

Free pages are additionally stored in a linked list of \texttt{PageInfo}
structs called the \texttt{page\_free\_list}. Using a linked list lets the
kernel return a free page in constant time.

We wrote the following functions to manage physical pages:
\begin{itemize}
\item \texttt{page\_alloc} is used to allocate a page of physical memory
\item \texttt{page\_free} is used to put a page on the free list
\item \texttt{page\_decref} and \texttt{page\_incref} are used to manage
reference counts of pages
\end{itemize}
With this infrastructure in place, we were ready to set up the page table so
that we could use virtual memory.

% TODO: maybe describe our memory corruption checks?


\subsection{Page table theory}
To explain how our operating system implements virtual memory, it is necessary
to introduce some theory about the page table.

The page table is a two-level table whose main purpose is to let the processor
translate a virtual address to a physical address.  Conceptually, the x86 page
table is a 1024-ary tree of height 2. The physical address of the page table
-- the root of the tree -- can be found in the \gls{cr3} register.

The first level of the page table is called the Page Directory. It contains
1024 Page Directory Entries (\gls{pde}s). Each \gls{pde} points to a
second-level node in the page table.
Each second-level table holds 1024 Page Table
Entries (\gls{pte}s). It is possible to map a virtual address to a \gls{pte}.
The \gls{pte} then holds the physical address to which the virtual address
should map. It also holds some status bits.

The status bits of \gls{pte}s and \gls{pde}s determine such features as
whether the page is writable, and whether it is accessible to user-mode code.
There is also a "present" bit, which determines whether the page is virtual
address maps to a physical page at all, or if accesses should cause a page
fault instead.

To translate from a virtual to a physical address, it is necessary to walk the
page table. For sake of illustration, assume that the processor is instructed
to access a virtual address $v = 0x11223344$. The processor first looks in the
\gls{cr3} register to find the root of the page table. It then uses the
higher-order 10 bits of $v$ as an index into the page table. In this case, we
have:
$$ v = 0x11223344 = 0b10001001000100011001101000100 $$
So the 10 higher-order bits are:
$$ 0b1000100100 = 548 $$
At index 548 into the page table, the processor finds a \gls{pde}. It extracts
a physical address from the \gls{pde} to find a page directory. It then uses
the next 10 high-order bits of $v$ as an index into the page directory. We
have:
$$ 0b0100011001 = 281 $$
So the processor looks at index 281 into the page directory and finds a
\gls{pte}. The \gls{pte} holds some status bits, which the processor can use
to check whether the page is present, and whether access permissions are
appropriate. If not, a page fault is generated. If all goes well, the
\gls{pte} holds the physical address of the page that should be accessed. The
lower-order 12 bits of the virtual address are used to index into the physical
page, and the processor is finally done with address translation.

This is a costly process, and in practice the job is done by specialized
hardware called a Memory Management Unit (\gls{mmu}). Additionally, a cache
called the Translation Lookaside Buffer (\gls{tlb}) holds the results of
recent translations, to avoid having to walk the page table too often.


\subsection{Page table management}
We wrote the following functions to manage the page table:
\begin{itemize}
\item \texttt{pgdir\_walk} is the main workhorse of the subsystem, since it is
called by most of the other functions. It has the same function as the MMU; it
is given a page table and a virtual address, and it walks over the table to
find the corresponding \gls{pte}, allocating new levels of the table if needed,
using \texttt{page\_alloc} from the previous section.
\item \texttt{page\_insert} is used to insert a physical page into a page
table at a given virtual address. In other words, it finds a \gls{pte} for a virtual
address and stores the physical address there.
\item \texttt{page\_lookup} finds the physical address of a page, given a
virtual address.
\item \texttt{page\_remove} invalidates a \gls{pte} in a page table.
\end{itemize}
The kernel uses these functions to set up the page table. This involves
allocating pages of physical memory and inserting them into appropriate places
in the page table. 

It is up to us where the different things should go. Figure \ref{memlayout}
contains a diagram which gives a simplified overview of the address space. For
a more complete version, see the file \texttt{inc/memlayout.h}.
\begin{figure}[h!]
    \centering
\begin{Verbatim}[fontsize=\small]
Virtual memory map:                                  Permissions
                                                     kernel/user
   4 Gig -------->  +------------------------------+
                    :              .               :
                    :              .               :
                    |------------------------------| RW/--
                    |                              | RW/--
                    |      Kernel code, data       | RW/--
                    |                              | RW/--
   KERNBASE, ---->  +------------------------------+ 0xf0000000      
   KSTACKTOP        |     CPU0's Kernel Stack      | RW/--  KSTKSIZE 
                    +------------------------------+                 
                    |     CPU1's Kernel Stack      | RW/--  KSTKSIZE 
                    +------------------------------+                 
                    :              .               :                 
                    :              .               :                 
                    +------------------------------+ 0xef800000
                    |  Cur. Page Table (User R-)   | R-/R-  PTSIZE
   UVPT      ---->  +------------------------------+ 0xef400000
                    |          RO PAGES            | R-/R-  PTSIZE
   UPAGES    ---->  +------------------------------+ 0xef000000
                    :              .               :                 
                    :              .               :                 
   USTACKTOP  --->  +------------------------------+ 0xeebfe000
                    |      Normal User Stack       | RW/RW  PGSIZE
                    :              .               :                 
                    :              .               :                 
                    +------------------------------+
                    :              .               :
                    :              .               :
                    +------------------------------+
                    |     Program code, data       |
   UTEXT -------->  +------------------------------+ 0x00800000
                    :              .               :                 
                    :              .               :                 
                    +------------------------------+ 0x00000000
\end{Verbatim}
    \caption{The virtual address space of the kernel}
    \label{memlayout}
\end{figure}
The diagram shows that the kernel code resides starting at virtual address
0xf0000000. The kernel stacks, used by processors when running kernel-mode
code, reside just below, between 0xefc00000 and 0xf0000000. Further down in
the address space, between 0xef400000 and 0xef800000, we have the User Virtual
Page Table (UVPT) area, which gives user-mode programs read-only access to the
page table, enabling certain exokernel-style programs to work. The stack of
the user-mode program starts at 0xeebfe000 and grows toward lower addresses.
The user-mode program code and data resides at 0x00800000.

After allocating a page table and updating it to reflect all these
conventions, we update the \gls{cr3} register to atomically update the page
table. Finally we set a bit in \gls{cr0} to enable paging.

Our system now has virtual memory. This means that user-mode programs cannot
access kernel memory, since we have not set the user bit in the PTEs for this
memory. Furthermore, user-mode programs cannot interfere with each other; they
will each be given their own separate page table, where none of the physical
addresses overlap by default.


% TODO: make sure we describe that the user bit isn't set in kernel pages, and
% that's what gives us security.


%%%%% LAB 3 %%%%%
\section{Lab 3}

The goal of this lab was to get a user-mode program running as a process in
its own virtual address space. To accomplish this, we needed to write
functions to manage processes and another \gls{elf} file loader. If the process
triggers an exception, such as a division by zero, our kernel additionally
needs to handle this. Finally we implemented a system call mechanism to e.g.
let programs perform input and output.

\subsection{Process management}
Each process has some associated information. This includes its state
(running, runnable, killed, etc.), its process ID, its parent process ID, its
page directory, and so on. All this information is stored in a struct
\texttt{Env}. The process subsystem is similar to the page subsystem; an
array, \texttt{envs}, holds the \texttt{Env} struct of each process on the
system, and free environments are stored in a linked list called
\texttt{env\_free\_list}. We implemented functions for creating, initializing,
and destroying a process.

\subsection{ELF loading}
The kernel also needs a way to load a program into an address space. Programs
are represented as \gls{elf} files. This let us reuse our \gls{elf} loading code from our
boot loader.

To load a program, the kernel first allocates a fresh page table. The kernel
then walks over each section in the \gls{elf} file, figures out the virtual address
at which the section should go from the \gls{elf} file, allocates corresponding
physical pages, inserts them into the page table, and copies the code or data
from the program into the physical pages.

Note that we have not yet introduced a file system, so it is not immediately
clear where the kernel can find the programs which it should load. To solve
this problem we embed each user-mode program into the kernel as a blob of
binary data. In a later section we describe our implementation of a proper
file system for holding programs and data.

\subsection{Context switching}
To actually run a process, we need to perform a context switch. The
\texttt{Env} struct includes the metadata for a process, including its
registers. To perform a context switch, we first restore the saved
general-purpose registers by using the \texttt{popal} instruction. We also
load the page table of the process into \gls{cr3}.

We then issue the \texttt{iret} instruction, which restores the saved
\gls{eip}, \gls{esp}, \gls{eflags}, and \gls{cs} registers. This transfers
execution to user-mode code. The lower two bits of the \gls{cs} register
determine the Current Privilege Level (\gls{cpl}) of the processor. This was
previously 0, since the kernel runs in ring 0. By setting this to 3 during the
\texttt{iret}, the processor switches to user-mode operation, i.e., ring 3.

At this point we were able to run user-mode code in its own address space.
Unfortunately the code had no way to give control back to the kernel, so it
simply ran forever, or at least until it triggered an exception or interrupt,
which caused the whole system to crash.


\subsection{Theory of exceptions and interrupts}
While executing an instruction, the processor may trigger an exception. This
could e.g. happen due to a division by zero, or due to an illegal memory
access. When an exception occurs, the processor performs a context switch to
enter kernel mode. Then it runs some handler code specific to the exception.

The processor may also occasionally trigger an interrupt. This often happens
for asynchronous reasons; examples could be receiving a new network packet or
key press. Interrupts can also happen for synchronous reasons; for example, an
interrupt is raised as a result of executing the \texttt{int 0x80} instruction
which is commonly used for system calls. The behavior is the same for
exceptions; a context switch occurs to run a handler in kernel mode.

We now describe how the processor knows which code to run when an interrupt or
exception is raised. Exceptions and interrupts have numbers. Exceptions are
numbered from 0 to 31, and interrupts are numbered from 32 to 255.
% TODO: give some examples from http://wiki.osdev.org/Exceptions in a table.

These numbers specify an index into a table called the Interrupt Descriptor
Table (\gls{idt}). The physical address of the \gls{idt} is stored in the IDT
Register (\gls{idtr}), which can be read and set using the \texttt{lidt} and
\texttt{sidt} instructions, respectively.

The \gls{idt} table entry describes the address at which the handler for the
given interrupt resides.

As noted, an exception or interrupt triggers a context switch. Therefore the
processor needs to know on which stack it should save the registers of the
faulting process. To find this \gls{esp} value, the processor reads the Task
Register (\gls{tr})) which is an index into the \gls{gdt}. The \gls{gdt} entry
contains the address of a data structure called the Task State Segment
(\gls{tss}). The processor reads the new \gls{esp} value from the \gls{tss}.

To sum up: when an exception or interrupt occurs, the corresponding number is
looked up in the \gls{idt} to find the new \gls{eip} value. The \gls{tr},
\gls{gdt} and \gls{tss} are used to find the new \gls{esp} value. The
processor uses this information to store the registers of the faulting process
onto the new stack and execute the relevant handler code.


\subsection{Handling exceptions and interrupts}
We wrote a common function, \texttt{trap}, which is called whenever an
exception or interrupt occurs. For each exception and interrupt, we filled in
its \gls{idt} entry with a small stub which passes the number of the exception
or interrupt as the first argument in a call to \texttt{trap}.

The typical result of an exception is that the kernel terminates the running
process. However exceptions can also occur in kernel mode, in which case there
is a bug in the kernel. This results in a kernel panic, making the kernel
print the exception and hang.



\subsection{Handling system calls}
A process often needs to ask the kernel to perform some task for it. This
could e.g. involve printing text onto the console, reading a character from
the keyboard, or spawning a new child process. We needed to implement a
mechanism for triggering system calls in our kernel.

On the x86 architecture, the typical approach is to use the \texttt{int}
instruction, which triggers an interrupt when executed. On Linux, interrupt
0x80 is used for system calls, but we are free to use any interrupt, so we
arbitrarily chose number 0x30. This means that a program uses the \texttt{int
0x30} instruction to perform a system call. The interface was up to us, but we
kept it fairly standard; the \texttt{eax} register holds the system call
number, while arguments go in registers \texttt{ebx}, \texttt{ecx}, etc.

The \texttt{trap} function recognizes interrupt number 0x30 and calls the
\texttt{syscall} function, which uses a large \texttt{switch} to delegate each
system call to a specific handler.

We wrote system call handlers for input and output of a single character. At
this point we were able to run simple user-mode programs and have them
interact with the user. The programs could terminate themselves with a
specific system call, or by triggering any exception.


%%%%% LAB 4 %%%%%
\section{Lab 4}
- lab 4
	- preemptive multitasking
		- starting multiple processors
		- simple scheduler with yields
		- preemption (clock signals)
	- process forking with CoW
		- simple fork
		- CoW fork
	- IPC


%%%%% LAB 5 %%%%%
\section{Lab 5}
- lab 5
	- file system
	- shell


%%%%% LAB 6 %%%%%
\section{Lab 6}
- lab 6
	- networking: writing an e1000 card driver


%%%%% GRAPHICS LAB %%%%%
\section{Graphics Lab}
- graphics

%%%%% HARDWARE LAB %%%%%
\section{Hardware Lab}
- hardware



- conclusion

% TODO: we could include screenshots to make things more concrete
% TODO: include (a link to) the source code somehow

% TODO: question: is it a good idea to have "mistakes made" and "lessons
% learned"? If so, how do we do this without it sounding too informal?



% TODO: add references (some links are in writeup txt files)




\begin{thebibliography}{1}

% use like this: \cite{sigar1, sigar2}

% \bibitem{proc}
% Procyon,
% \\\texttt{http://bitbucket.org/mstrobel/procyon}
% 
% \bibitem{em} 
% Exam Monitor website.
% \\\texttt{http://exammonitor.dk}
% 
% \bibitem{jnlp}
% Exam Monitor JNLP file.
% \\\texttt{http://login.exammonitor.dk/exam.jnlp}
% 
% \bibitem{sigar1}
% Hyperic SIGAR website.
% \\\texttt{https://support.hyperic.com/display/SIGAR/Home}
% 
% \bibitem{sigar2}
% libsigar at GitHub.
% \\\texttt{https://github.com/hyperic/sigar}
% 
% \bibitem{sigarapache}
% The license file of SIGAR.
% \\\texttt{https://github.com/hyperic/sigar/blob/master/LICENSE}
% 
% \bibitem{agents}
% The package java.lang.instrument.
% \\\texttt{https://docs.oracle.com/javase/7/docs/api/java/lang/instrument/package-summary.html}
% 
% \bibitem{javassist}
% Javassist website.
% \\\texttt{http://www.javassist.org}
% 
% \bibitem{openjdk}
% OpenJDK website.
% \\\texttt{http://openjdk.java.net/}
% 
% \bibitem{webportal}
% Exam Monitor web portal.
% \\\texttt{https://sdu.exammonitor.dk/myexams.php}
% 
% \bibitem{x86harmful} 
% Joanna Rutkowska. Intel x86 considered harmful. 2015.
%  
% \bibitem{sokintro} 
% Bhushan Jain, Mirza Basim Baig, Dongli Zhang, Donald E. Porter, and Radu Sion.
% SoK: Introspections on Trust and the Semantic Gap. 2014.
% 
% \bibitem{appshield} 
% Yueqiang Cheng, Xuhua Ding, Robert H. Deng. AppShield: Protecting Applications
% against Untrusted Operating System. 2013.
% 
% \bibitem{towardsappsec} 
% Dan R. K. Ports, Tal Garfinkel. Towards Application Security on Untrusted
% Operating Systems. 2008.
% 
% \bibitem{haven} 
% Andrew Baumann, Marcus Peinado, and Galen Hunt. Shielding Applications from an
% Untrusted Cloud with Haven. In \emph{Proceedings of the 11th USENIX Symposium
% on Operating Systems Design and Implementation.} 2014.
% 
% \bibitem{sokhiee} 
% Fengwei Zhang, Hongwei Zhang. SoK: A Study of Using Hardware-assisted Isolated
% Execution Environments for Security. In \emph{Hardware and Architectural
% Support for Security and Privacy (HASP '16)}. 2016.
% 
% \bibitem{sgxexplained} 
% Victor Costan and Srinivas Devadas. Intel SGX Explained. 2016.
% 
% \bibitem{malwareinenclaves} 
% Jeroen van Prooijen. The Design of Malware on Modern Hardware: Malware Inside
% Intel SGX Enclaves. 2016.
% 
% \bibitem{enclavesinpractice} 
% JP Aumasson, Luis Merino. SGX Secure Enclaves in Practice: Security and Crypto
% Review. Presented at \emph{Black Hat USA 2016}.
% 
% \bibitem{opensgx} 
% Prerit Jain, Soham Desai, Seongmin Kim, Ming-Wei Shih, JaeHyuk Lee,
% Changho Choi, Youjung Shin, Taesoo Kim, Brent Byunghoon Kang, Dongsu Han.
% OpenSGX: An Open Platform for SGX Research. 2016.
% 
% \bibitem{iago} 
% Stephen Checkoway, Hovav Shacham. Iago Attacks: Why the System Call
% API is a Bad Untrusted RPC Interface. 2013.

\end{thebibliography}

\printglossary[title=Abbreviations]



\end{document}

