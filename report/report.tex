\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{color}
\usepackage{bm}
\usepackage{listings}
\usepackage{soul,xcolor}
\usepackage[htt]{hyphenat} % allows breaks inside texttt
\setstcolor{red}

\lstset{language=C}
\lstset{basicstyle=\ttfamily\footnotesize}



\title{
\line(1,0){250}\\
\Large \bfseries
TODO: write a \\
nice title here
\line(1,0){250}
}
\author{Thomas Hybel}
\date{Aarhus University \\ October 2017}

\begin{document}
\pagenumbering{roman}
\maketitle

\begin{abstract} 
\noindent 
TODO: write an abstract here.
\end{abstract}
\newpage

\tableofcontents
\newpage
\pagenumbering{arabic}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Introduction}


- introduction
	- what are we trying to do
	- how are we doing it
		- following the course from MIT
	- why are we doing it
	- overview of the coming chapters

% TODO: write about our development environment, i.e., that we're using QEMU.

% TODO: write that you can use "git checkout lab1" to go back to the end of
% lab1, etc.


%%%%% LAB 1 %%%%%

\section*{Lab 1}

In this lab we wrote initialization code for our operating system. This code
sets up a rudimentary page table and switches the processor from 16-bit real
mode to 32-bit protected mode. We also wrote a boot loader, which is a small
program that loads the main kernel from disk and transfers control to it.

\subsection*{The boot process}
To understand the purpose of a boot loader, it is first necessary to have an
overview of the process which an x86 machine goes through upon startup.

% source: https://en.wikipedia.org/wiki/BIOS
When an x86 machine starts, its BIOS code is run. The BIOS initializes some of
the system's hardware components (e.g., keyboard, graphics card, and hard
drive). The BIOS will then load one sector (512 bytes) from the boot medium
into memory at a hard-coded address (0x7C00). Once this first sector is loaded
into memory, the BIOS will transfer execution to the loaded code.

The first sector will typically contain a small program known as the boot
loader. Its purpose is to load the main kernel from disk and transfer
execution to it.

Before the boot loader loads the kernel, we first run some initialization code
which sets up a more comfortable environment for the boot loader and kernel to
work in.



\subsection*{Initialization code}
When the BIOS jumps into our code, the processor is running in 16-bit real
mode. However the code produced by a modern compiler expects to run in 32-bit
protected mode. We therefore needed to write code which performs this
switching of processor modes.

The main difference between real mode and protected mode is how address
resolution is performed. In real mode, accessing a physical address is done
using a segment selector register and a general-purpose register. In
contast, protected mode allows (but does not require) the use of
\emph{paging}, i.e., the mapping from virtual from physical addresses using a
page table.

Since we want our operating system to use virtual memory, we certainly want to
switch to protected mode. We do not immediately enable paging, however.

To switch to protected mode, a bit needs to be set in the status register
\texttt{cr0}. We do so with the following assembly code:
\begin{verbatim}
# protected mode enable flag
.set CR0_PE_ON, 0x1 
movl    %cr0, %eax
orl     $CR0_PE_ON, %eax
movl    %eax, %cr0
\end{verbatim}

To switch to 32-bit mode, we must update the \texttt{cs} (code
segment) register. This register is an offset into a table called the Global
Descriptor Table (GDT) which contains a number of descriptors. Each descriptor
has a bit which determines whether the chosen segment is a 32-bit or a 16-bit
segment. We use the \texttt{ljmp} instruction to update the \texttt{cs}
register.
% TODO: possibly elaborate more on the GDT.

Once our code has switched to 32-bit protected mode, it executes the boot
loader. At this point the processor is in a state where it can execute
compiled C code, which means that we no longer need to hand-write assembly.

The file \texttt{boot/boot.S} contains the code that performs the described
tasks.



\subsection*{The boot loader}
It is the task of the boot loader to load the main kernel and transfer
execution to it. The boot loader must do this using no more than 512 bytes of
code, minus the bytes used by the initialization code.

Our kernel will be compiled into an Executable and Linkable Format (ELF) file.
The boot loader will parse this ELF file, using the information therein to
load the code and data of the kernel to the right physical addresses.

% TODO: possibly include information about the ELF file format here.

Once the boot loader has finished loading the kernel, it determines the entry
point address from the ELF file and jumps there, transferring execution to the
kernel.

\subsection*{Minimal kernel code}
At this point our kernel can finally run. However it does not yet have much
functionality. Unlike user-mode programs, the kernel does not have access to a
C standard library, unless we write one ourselves.


% TODO: document that we were given the serial connection code via the MIT
% course
As a start, we would like to have the ability to input and output text.
Our kernel can use the \texttt{inb} and \texttt{outb} instructions to
communicate with the outside world via a serial connection. We used this to
write out a message and confirm that the kernel runs.


% TODO: should note that our boot loader isn't actually used in the end.




%%%%% LAB 2 %%%%%

\section*{Lab 2}

- lab 2
	- alloc and free physical pages
	- page table management



%%%%% LAB 3 %%%%%
\section*{Lab 3}
- lab 3
	- goal: make user-space process run
	- functions for keeping track of proceses
	- ELF loader
	- context switching
	- handling exceptions
	- handling syscalls


%%%%% LAB 4 %%%%%
\section*{Lab 4}
- lab 4
	- preemptive multitasking
		- starting multiple processors
		- simple scheduler with yields
		- preemption (clock signals)
	- process forking with CoW
		- simple fork
		- CoW fork
	- IPC


%%%%% LAB 5 %%%%%
\section*{Lab 5}
- lab 5
	- file system
	- shell


%%%%% LAB 6 %%%%%
\section*{Lab 6}
- lab 6
	- networking: writing an e1000 card driver


%%%%% GRAPHICS LAB %%%%%
\section*{Graphics Lab}
- graphics

%%%%% HARDWARE LAB %%%%%
\section*{Hardware Lab}
- hardware



- conclusion

% TODO: we should have an abbreviations list
% TODO: we could include screenshots to make things more concrete
% TODO: include (a link to) the source code somehow

% question: is it a good idea to have "mistakes made" and "lessons learned"?
% If so, how do we do this without it sounding too informal?







\begin{thebibliography}{1}

% use like this: \cite{sigar1, sigar2}

% \bibitem{proc}
% Procyon,
% \\\texttt{http://bitbucket.org/mstrobel/procyon}
% 
% \bibitem{em} 
% Exam Monitor website.
% \\\texttt{http://exammonitor.dk}
% 
% \bibitem{jnlp}
% Exam Monitor JNLP file.
% \\\texttt{http://login.exammonitor.dk/exam.jnlp}
% 
% \bibitem{sigar1}
% Hyperic SIGAR website.
% \\\texttt{https://support.hyperic.com/display/SIGAR/Home}
% 
% \bibitem{sigar2}
% libsigar at GitHub.
% \\\texttt{https://github.com/hyperic/sigar}
% 
% \bibitem{sigarapache}
% The license file of SIGAR.
% \\\texttt{https://github.com/hyperic/sigar/blob/master/LICENSE}
% 
% \bibitem{agents}
% The package java.lang.instrument.
% \\\texttt{https://docs.oracle.com/javase/7/docs/api/java/lang/instrument/package-summary.html}
% 
% \bibitem{javassist}
% Javassist website.
% \\\texttt{http://www.javassist.org}
% 
% \bibitem{openjdk}
% OpenJDK website.
% \\\texttt{http://openjdk.java.net/}
% 
% \bibitem{webportal}
% Exam Monitor web portal.
% \\\texttt{https://sdu.exammonitor.dk/myexams.php}
% 
% \bibitem{x86harmful} 
% Joanna Rutkowska. Intel x86 considered harmful. 2015.
%  
% \bibitem{sokintro} 
% Bhushan Jain, Mirza Basim Baig, Dongli Zhang, Donald E. Porter, and Radu Sion.
% SoK: Introspections on Trust and the Semantic Gap. 2014.
% 
% \bibitem{appshield} 
% Yueqiang Cheng, Xuhua Ding, Robert H. Deng. AppShield: Protecting Applications
% against Untrusted Operating System. 2013.
% 
% \bibitem{towardsappsec} 
% Dan R. K. Ports, Tal Garfinkel. Towards Application Security on Untrusted
% Operating Systems. 2008.
% 
% \bibitem{haven} 
% Andrew Baumann, Marcus Peinado, and Galen Hunt. Shielding Applications from an
% Untrusted Cloud with Haven. In \emph{Proceedings of the 11th USENIX Symposium
% on Operating Systems Design and Implementation.} 2014.
% 
% \bibitem{sokhiee} 
% Fengwei Zhang, Hongwei Zhang. SoK: A Study of Using Hardware-assisted Isolated
% Execution Environments for Security. In \emph{Hardware and Architectural
% Support for Security and Privacy (HASP '16)}. 2016.
% 
% \bibitem{sgxexplained} 
% Victor Costan and Srinivas Devadas. Intel SGX Explained. 2016.
% 
% \bibitem{malwareinenclaves} 
% Jeroen van Prooijen. The Design of Malware on Modern Hardware: Malware Inside
% Intel SGX Enclaves. 2016.
% 
% \bibitem{enclavesinpractice} 
% JP Aumasson, Luis Merino. SGX Secure Enclaves in Practice: Security and Crypto
% Review. Presented at \emph{Black Hat USA 2016}.
% 
% \bibitem{opensgx} 
% Prerit Jain, Soham Desai, Seongmin Kim, Ming-Wei Shih, JaeHyuk Lee,
% Changho Choi, Youjung Shin, Taesoo Kim, Brent Byunghoon Kang, Dongsu Han.
% OpenSGX: An Open Platform for SGX Research. 2016.
% 
% \bibitem{iago} 
% Stephen Checkoway, Hovav Shacham. Iago Attacks: Why the System Call
% API is a Bad Untrusted RPC Interface. 2013.

\end{thebibliography}


\end{document}

